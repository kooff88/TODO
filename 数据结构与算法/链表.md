## 链表 Linked List

应用场景： LRU 缓存淘汰算法。

缓存淘汰策略，常见：

1. 先进先出策略 FIFO（First In, First Out）。
2. 最少使用策略 LFU（Least Frequently Used）。
3. 最近最少使用策略 LRU（Least Recently Used）。

对比数组： 数组需要一块连续的内存空间， 链表是一组零散的内存块串联起来就可以。

三类链表： 1. 单链表 2. 双向链表 3. 循环链表

单链表：

```
后继指针 ( next ): 记录下一个节点地址的指针。

头节点

尾节点： 指向 空地址null

插入，删除操作非常快速， 空间复杂度O(1)。

随机访问性能没有数组好，需要O(n)的时间复杂度。
```

循环链表：

```
尾节点指针 指向首节点。 首位相连

```

双向链表：

```
有前驱指针 prew 和 后继指针 next

```

实践：

```
从链表中删除一个数据有两种情况：

1. 删除节点中 “值等于某个给定值”的节点； 删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。
2. 删除给点指针指向的节点  ，删除操作双向链表只需要在 O(1) 的时间复杂度内就搞定了！

```

链表代码技巧：

### 理解指针或引用的含义

存储所指对象的内存地址

指针： C 引用： Java Pathon

```
将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，
指向了这个变量，通过指针就能找到这个变量。
```

### 警惕指针丢失和内存泄漏

```
p -> next = x; // 将p的 next 指针指向 x 结点。
x -> next = p -> next; // 将x的结点的next指针指向b结点。

// 上面代码错误： 第一步完成后 p 的next 指针已经不再指向b结点，而指向x，第二行相当于自己指向自己。
// 改正： 将上面两行代码颠倒顺序就OK。

```

删除链表结点时，也一定要记得手动释放内存空间。

### 利用哨兵简化实现难度

链表中插入第一个结点

```
if (head == null) {
    head = new_node
}
```

删除结点 p 的后继结点。（无哨兵）

```
p -> next = p -> next -> next;
```

删除链表中的最后一个结点，前面的删除代码就不工作了。（无哨兵）

```
if (head -> next == null){
    head = null;
}
```

有哨兵（c 语言）：

```
// 在数组a中,查找key, 返回key所在的位置
// 其中, n表示数组a的长度

int find( char* a, int n, char key ) {
    // 边界条件处理，如果a为空， 或者 n<=0, 说明数组中没有数据，就不用while 循环比较了
    if (a == null || n<=0 ) {
        return -1;
    }

    int i = 0;
    // 这里有两个比较操作: i< n和 a[i] == key.

    while ( i < n ) {
        if ( a[i] == key ) {
            return i;
        }
        ++i;
    }

    return -1;
}

```

代码二

```
  // 在数组a中，查找key，返回key所在的位置
  // 其中，n表示数组a的长度
  // 我举2个例子，你可以拿例子走一下代码
  // a = { 4,2,3,5,9,6 } n=6 key=7
  // a = { 4,2,3,5,9,6 } n=6 key=6

  int find(char*a, int n, char key) {
      if (a == null || n <=0 ) {
          return -1;
      }

      // 这里因为要将a[n-1] 的值替换成key， 所以要特殊处理这个值
      if (a[n-1] == key) {
          return n-1;
      }

      // 把 a[n-1] 的值临时保存在变量temp中,以便之后恢复。temp = 6。
      // 之所以这样做的目的是： 希望find() 代码不要改变a数组中的内容。
      char tmp = a[n-1];
      // 把key 的值放到 a[n-1] 中，此时 a = { 4,2,3,5,9,7 }
      a[n-1] = key;

      int i = 0;
      // while 循环比起代码一，少了 i < n 这个比较操作
      while (a[i] != key) {
          ++i;
      }

      // 恢复 a[n-1] 原来的值，此时 a = { 4,2,3,5,9,6 }
      a[n-1] = tmp;

      if ( i == n-1 ) {
          // 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1 return -1;
          return -1;
      }else {
           // 否则，返回i，就是等于key值的元素的下标
            return i;
      }
  }

```

### 重点留意边界条件处理

检查链表代码是否正确的边界条件有以下：

```
1. 如果链表为空时，代码是否能正常工作?
2. 如果链表只包含一个结点时,代码是否能正常工作?
3. 如果链表只包含两个结点时，代码是否能正常工作?
4. 代码逻辑在出库头结点和尾结点的时候，是否能正常工作?

```

### 举例画图，辅助思考
