## B+树

1. 解决问题的前提是定义清楚问题

2. 尝试用学过的数据结构解决这个问题

3. 改造二叉查找树来解决这个问题

二叉查找树支持按照区间来查找数据，我们可以对它进行这样的改造：

通常内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的。  
读取同样大小的数据，从磁盘中读取花费的时间，是从内存中读取所花费时间的上万倍，甚至几十万倍。

区间查找的功能就实现了。不过，为了节省内存，如果把树存储在硬盘中  
，那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。

比起内存读写操作，磁盘 IO 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 IO 操作.

如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3，最多只要 3 次磁盘 IO 就能获取到数据。

```
不管是内存中的数据，还是磁盘中的数据，操作系统都是按页
（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，
一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。
所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。
```

正是因为要时刻保证 B+ 树索引是一个 m 叉树，所以，索引的存在会导致数据库写入的速度降低。  
实际上，不光写入数据会变慢，删除数据也会变慢。

B+树特点:

```
每个节点中子节点的个数不能超过 m，也不能小于 m/2；

根节点的子节点个数可以不超过 m/2，这是一个例外；

m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；

通过链表将叶子节点串联在一起，这样可以方便按区间查找；

一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。

```

而 B 树实际上是低级版的 B+ 树，或者说 B+ 树是 B 树的改进版。B 树跟 B+ 树的不同点主要集中在这几个地方：

```
B+ 树中的节点不存储数据，只是索引，而 B 树中的节点存储数据；

B 树中的叶子节点并不需要链表来串联。
```
