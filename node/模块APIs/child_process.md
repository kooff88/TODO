# child_processNodeJs 是一个单进程的语言，不能像Java那样可以创建多线程来并发执行。当然在大部分情况下，NodeJs是不需要并发执行的，  因为它是事件驱动性永不阻塞。但单进程也有个问题就是不能充分利用CPU的多核，根据前人的经验，可以通过创建多个进程来充分  利用CPU多核， 并且Node通过了child_process模块来创建完成多进程的操作。  child_process模块给予node任意创建子进程的能力,node官方文档对于child_proces模块给出了四种方法，映射到操作系统  其实都是创建子进程。但对于开发者而已，这几种方法的api有点不同。  ```	child_process.exec(command[,options][,callback]) 启动	子进程来执行shell命令，可以通过回调参数来获取脚本shell执行结果。  	child_process.execfile(file[,args][,options][,callback])	与exec类型不同的是，它执行的不是shell命令而是一个可执行文件	child_process.spawn(command[,args][,options])仅仅执行一个shell命令，不需要获取执行结果	child_process.fork(modulePath[,args][,options]) 可以用node	执行的.js文件，也不需要获取执行结果。fork出来的子进程一定是node进程.```node 与 子进程之间的通信是使用 IPC管道机制完成。如果子进程也是node进程(使用fock)，则可以使用监听message事件和  send()来通信。  main.js```js	var cp = require('child_process');	// 只有使用fork才可以使用message事件和send()方法.	var n = cp.fork('./child.js');	n.on('message', function(m){		console.log(m);	})	n.send({"message": "hello" });```child.js```var cp = require('child_process');process.on('message', function(m){	console.log(m);})process.send({"message":'hello I am child' })```父子进程之间会创建IPC通道，message事件和send()便利用IPC通道通信。  ### 句柄传递学会了如何创建子进程后，我们创建一个HTTP服务并启动多个进程来共同做到充分利用CPU多核。  worker.js```js	var http = require('http');	http.createServer(function(req,res){		res.end('Hello World');		// 监听随机端口	}).listen(Math.round((1+ Math.random()) * 1000), '127.0.0.1');```main.js```js	var fork = require('child_process').fork;	var cpus = require('os').cpus();	for (var i=0; i<cpus.length; i++) {		fork('./worker.js')	}```上述代码会根据你的cpu核数量的fork进程，每个进程监听一个随机端口来提供HTTP服务。  上述就完成了一个经典的Master-Worker主从复制模式。在分布式应用中用于并行处理业务，具备良好的收缩性和稳定性。这里需要注意，fork一个进程代价是昂贵的，  node 单进程事件驱动具有良好的性能。此例的多个fork进程是为了充分利用CPU的核，并非解决并发问题。  上述示例鼬哥不太好的地方就是占有了太多端口，那么能不能对于多个子进程全部使用同一个端口从而对外提供http服务也只是使用这个端口。尝试将上述的端口随机数  改为8080,启动会发现抛出如下异常。  ```  events.js 72  				throw er; // Unhandled 'error' event  Error: listen. EADDRINUSE  XXXX```抛出端口被占有的异常，这意味着只有一个worker.js才能监听8080端口，而其余的会抛出异常。  如果要解决对外提供一个端口的问题，可以参考 nginx反向代理的做法。对于Master进程使用80端口对外提供服务，而对于fork的进程则使用随机端口，  Master进程接受到请求就将其转发到fork进程中。  对于刚刚所说的代理模式，由于进程每收到一个链接会使用掉一个文件描述符，因此代理模式中客户端连接到代理进程，代理进程再去连接fork进程会使用掉  两个文件描述符，OS中文件描述符是有限的，为了解决这个问题，node引入进程间发送句柄的功能。  在node的IPC进程通讯API 中， send(message,[sendHandle])的第二个参数就是句柄。  句柄就是一种镖标示资源的引用，它的内部包含了指向对象的文件描述符。句柄可以用来描述一个socket对象，一个UDP套接字，一个管道  主进程向工作进程发送句柄意味着当主进程接收到客户端的socket请求后则直接将这个socket发送给工作进程，而不需要再与工作进程建立socket连接，则  文件描述符的浪费即可解决。我们来看示例代码：  main.js```js	var cp = require('child_process');	var child = cp.fork('./child.js');	var server = require('net').createServer();	// 监听客户端的连接	server.on('connection', function(socket){		socket.end('handled by parent');	});	// 启动监听8080端口	server.listen(8080, function () {		// 给子进程发送TCP服务器(句柄)		child.send('server',server)	}) ```child.js```js	process.on('message', function(m,server){		if (m === 'server') {			server.on('connection',function(socket){				socket.end('handle by child');			})		}	})```使用telnet或curl都可以测试```wang@wang ~/code/nodeStudy $ curl 192.168.10.104:8080handled by parentwang@wang ~/code/nodeStudy $ curl 192.168.10.104:8080handle by childwang@wang ~/code/nodeStudy $ curl 192.168.10.104:8080handled by parentwang@wang ~/code/nodeStudy $ curl 192.168.10.104:8080handled by parent```测试结果是每次对于客户端的连接，有可能父进程处理也有可能被子进程处理。现在我们尝试仅提供http服务，并且为了让父进程更加轻量，仅让父进程传递句柄给  子进程而不做请求处理：  main.js```js	var cp = require('child_process');	var child1 = cp.fork('./child.js');	var child2 = cp.fork('./child.js');	var child3 = cp.fork('./child.js');	var child4 = cp.fork('./child.js');	var server = require('net').createServer();	// 父进程将接收到的请求分发给子进程	server.listen(8080, function(){		child1.send('server', server);		child2.send('server', server);		child3.send('server', server);		child4.send('server', server);		// 发送完句柄后关闭监听		server.close();	})```child.js```js	var http = require('http');	var serverInChild = http.createServer(function(req,res){		res.send('I am child.Id' + process.pid);	});	// 子进程收到父进程传递的句柄（即客户端与服务器socket连接对象）	process.on('message', function(m, serverInParent){		if (m === 'server') {			// 处理与客户端的连接			serverInParent.on('connection',function(socket){				// 交给http服务来处理				serverInChild.emit('connection',socket);			})l		}	});```当运行上述代码，此时查看8080端口占有会如下结果：```wang@wang ~/code/nodeStudy $ lsof -i:8080COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEnode    5120 wang   11u  IPv6  44561      0t0  TCP *:http-alt (LISTEN)node    5126 wang   11u  IPv6  44561      0t0  TCP *:http-alt (LISTEN)node    5127 wang   11u  IPv6  44561      0t0  TCP *:http-alt (LISTEN)node    5133 wang   11u  IPv6  44561      0t0  TCP *:http-alt (LISTEN)```运行curl查看结果```wang@wang ~/code/nodeStudy $ curl 192.168.10.104:8080I am child.Id:5127wang@wang ~/code/nodeStudy $ curl 192.168.10.104:8080I am child.Id:5133wang@wang ~/code/nodeStudy $ curl 192.168.10.104:8080I am child.Id:5120wang@wang ~/code/nodeStudy $ curl 192.168.10.104:8080I am child.Id:5126wang@wang ~/code/nodeStudy $ curl 192.168.10.104:8080I am child.Id:5133wang@wang ~/code/nodeStudy $ curl 192.168.10.104:8080I am child.Id:5126```## child_process.execSync()返回值不为0时不要抛出错误  一个判断编译是否通过的程序。  ```jsvar execSync = require('child_process').execSync;var fs = require('fs');var cmd = 'g++ program.cpp -o program -02';console.log(cmd);execSync(cmd);if (! (fs.existsSync('program')))	console.log('Compile Fail');elseconsole.log('Compile Success');```果编译成功是没有问题的，但是编译失败的话，execSync会抛出一个错误，官网也有这样的说明 